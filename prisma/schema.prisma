generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum NotificationType {
  system
  event
  contract
  property
  appointment
  message
  user
}

enum NotificationStatus {
  unread
  read
}

enum UserRole {
  investor
  broker
  admin
  superadmin
}

enum UserActionsStatus {
  seen // seen and no action
  requested // booking created, waiting for approval
  confirmed // scheduled and approved
  completed // appointment done, user visited
  noShow // user did not attend
  canceled // appointment canceled
}

enum ContractStatus {
  draft // contract created but not yet signed
  pending // awaiting approval or payment
  active // signed and currently valid
  suspended // temporarily paused
  expired // reached end date
  terminated // ended early by one or both parties
  completed // fully executed and closed successfully
  canceled // canceled before activation
}

enum EventStatus {
  DRAFT
  UPCOMING
  OPEN
  // WAITLIST
  ENDED
  CANCELLED
}

model AppUser {
  id           String   @id @default(uuid())
  email        String   @unique
  passwordHash String
  role         UserRole
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // onboarding
  firstName   String?
  lastName    String?
  phone       String?
  nationality String?
  recidence   String?

  resetToken          String?
  resetTokenExpiry    DateTime?
  emailVerified       Boolean   @default(false)
  onboardingCompleted Boolean   @default(false)

  investorProfile InvestorProfile?
  brokerProfile   BrokerProfile?
  adminProfile    AdminProfile?
  appointments    Appointment[]

  propertyStatuses  UserPropertyStatus[]
  eventStatuses     UserEventStatus[]
  activityLogs      ActivityLog[]
  notifications     Notification[]
  globalNotificationViews GlobalNotificationView[]
}

model InvestorProfile {
  userId String  @id
  user   AppUser @relation(fields: [userId], references: [id], onDelete: Cascade)

  properties  Property[]
  contracts   Contract[]
  preferences InvestorPreferences?
}

model InvestorPreferences {
  investorProfileId String          @id
  investorProfile   InvestorProfile @relation(fields: [investorProfileId], references: [userId], onDelete: Cascade)

  investingInDubai       Boolean
  openToJointInvestments Boolean
  wantsAdvisorCall       Boolean
  interestedInEvents     Boolean
  createdAt              DateTime @default(now())
  updatedAt              DateTime @updatedAt
}

model BrokerProfile {
  userId    String     @id
  user      AppUser    @relation(fields: [userId], references: [id], onDelete: Cascade)
  contracts Contract[]
}

model AdminProfile {
  userId     String  @id
  department String?
  user       AppUser @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Property {
  id                String   @id @default(uuid())
  title             String
  description       String?
  area              String?
  buildingName      String?
  contractValue     Float    @default(1000) // for Investors
  developer         String?
  unitNo            String?
  floor             Int?
  condition         String?
  unitTotalSize     Float?
  apartmentSize     Float?
  balconySize       Float?
  status            String?
  latitude          Float?
  longitude         Float?
  city              String?
  country           String?
  images            String[]
  assets            String[]
  isActive          Boolean  @default(true)
  netRoiMin         Float? // e.g. 9
  netRoiMax         Float? // e.g. 11
  isTaxFreeZone     Boolean? // true/false
  keyBenefits       String[] // ["100% Foreign Ownership", "Tax-Free Zone", "Full Capital Repatriation"]
  freezoneAuthority String? // e.g. "DMCC Freezone"

  // Current vacancy status
  isVacant Boolean @default(true)

  // Admin
  serviceChargePerSqft Float?
  serviceChargeTotal   Float?
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  // ‚ùó owner is optional, survives if investor removed
  ownerId String?
  owner   InvestorProfile? @relation(fields: [ownerId], references: [userId], onDelete: SetNull)

  governmentLeases  GovernmentLease[]
  availabilitySlots AvailabilitySlot[]
  appointments      Appointment[]
  userStatuses      UserPropertyStatus[]
  contracts         Contract[]
  tenantLeases      TenantLease[]
}

model GovernmentLease {
  id          String   @id @default(uuid())
  propertyId  String
  startDate   DateTime
  endDate     DateTime
  monthlyRent Float

  property Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)
}

model TenantLease {
  id         String @id @default(uuid())
  propertyId String

  // Tenant details
  tenantName  String?
  tenantEmail String?
  tenantPhone String?

  // Lease terms
  leaseStart    DateTime
  leaseEnd      DateTime?
  monthlyRent   Float
  paymentMethod String?
  depositAmount Float?

  // Status
  isActive          Boolean @default(true)
  terminatedEarly   Boolean @default(false)
  terminationReason String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  property   Property                @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  statistics InvestmentStatistics[]

  @@index([propertyId])
  @@index([leaseStart, leaseEnd])
}

model AvailabilitySlot {
  id         String   @id @default(uuid())
  propertyId String
  startsAt   DateTime
  endsAt     DateTime
  capacity   Int      @default(1)

  property     Property      @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  appointments Appointment[]
}

model Appointment {
  id          String            @id @default(uuid())
  propertyId  String
  bookedById  String
  slotId      String?
  status      UserActionsStatus @default(requested)
  scheduledAt DateTime
  notes       String?

  property Property          @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  bookedBy AppUser           @relation(fields: [bookedById], references: [id], onDelete: Cascade)
  slot     AvailabilitySlot? @relation(fields: [slotId], references: [id], onDelete: SetNull)
}

model Contract {
  id           String         @id @default(uuid())
  propertyId   String
  investorId   String
  brokerId     String?
  contractCode String
  contractLink String?
  filesUrl     String[]
  
  // Contract dates and financial terms
  signedDate          DateTime?
  contractStart       DateTime?
  contractEnd         DateTime?
  contractValue       Float? // Total investment amount
  depositPaid         Float? // Initial deposit paid by investor
  investorPaymentMethod String? // How investor pays (e.g., "Bank Transfer", "Installments")
  paymentSchedule     String? // e.g., "Monthly", "Quarterly", "Annual"
  
  // Risk assessment
  vacancyRiskLevel String? // "Low", "Medium", "High"
  
  status ContractStatus @default(pending)
  notes  String?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  investor   InvestorProfile          @relation(fields: [investorId], references: [userId], onDelete: Cascade)
  broker     BrokerProfile?           @relation(fields: [brokerId], references: [userId], onDelete: SetNull)
  property   Property                 @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  statistics InvestmentStatistics[]
}

model InvestmentStatistics {
  id            String  @id @default(uuid())
  contractId    String
  tenantLeaseId String? // Which tenant was active this month
  month         Int     // 1-12
  year          Int

  // Income
  rentReceived Float @default(0)

  // Expenses
  serviceCharge   Float @default(0)
  maintenanceCost Float @default(0)
  otherExpenses   Float @default(0)

  // Calculated fields
  totalExpenses Float @default(0)
  netProfit     Float @default(0)
  roiPercentage Float @default(0)

  // Cumulative tracking for charts
  cumulativeProfit Float @default(0) // Running total profit
  cumulativeRoi    Float @default(0) // Running ROI %

  // Occupancy tracking
  daysOccupied Int     @default(0)
  daysVacant   Int     @default(0)
  wasVacant    Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  contract    Contract     @relation(fields: [contractId], references: [id], onDelete: Cascade)
  tenantLease TenantLease? @relation(fields: [tenantLeaseId], references: [id], onDelete: SetNull)

  @@unique([contractId, month, year])
  @@index([contractId])
  @@index([year, month])
}

model Event {
  id          String    @id @default(uuid())
  title       String
  description String?
  startsAt    DateTime
  endsAt      DateTime?
  location    String?

  // New fields
  totalMembers Int? // optional: can be stored or derived
  budget       Decimal?    @db.Decimal(10, 2)
  status       EventStatus @default(OPEN)
  image        String

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userStatuses UserEventStatus[]
}

model UserPropertyStatus {
  id         String   @id @default(uuid())
  userId     String
  propertyId String
  seen       Boolean  @default(false)
  viewedAt   DateTime @default(now())

  user     AppUser  @relation(fields: [userId], references: [id], onDelete: Cascade)
  property Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)

  @@unique([userId, propertyId])
  @@index([propertyId])
}

model UserEventStatus {
  id       String   @id @default(uuid())
  userId   String
  eventId  String
  viewedAt DateTime @default(now())

  status UserActionsStatus @default(seen)
  user   AppUser           @relation(fields: [userId], references: [id], onDelete: Cascade)
  event  Event             @relation(fields: [eventId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, eventId])
  @@index([eventId])
}

model ActivityLog {
  id        String   @id @default(uuid())
  userId    String
  type      String // e.g. "property_viewed", "event_seen", "login"
  entityId  String? // optional: link to property/event/etc
  metadata  Json? // store extra details if needed
  createdAt DateTime @default(now())

  user AppUser @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, type])
  @@index([entityId])
}

model Notification {
  id          String             @id @default(uuid())
  userId      String?
  type        NotificationType   @default(system)
  title       String
  message     String
  targetRoles UserRole[]
  link        String? // optional deep link (e.g. /contracts/123)
  status      NotificationStatus @default(unread)
  createdAt   DateTime           @default(now())
  isGlobal    Boolean?           @default(false)
  readAt      DateTime?
  json        Json?

  user AppUser? @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// Global Notifications: One notification, many users (reverse inbox pattern)
// Used for system-wide announcements, maintenance alerts, feature releases, etc.
model GlobalNotification {
  id          String                  @id @default(uuid())
  title       String
  message     String
  type        NotificationType        @default(system)
  targetRoles UserRole[] // Which roles should see this
  link        String? // Optional deep link
  priority    String                  @default("normal") // "low", "normal", "high", "critical"
  icon        String? // emoji or icon identifier
  json        Json? // Additional metadata
  startsAt    DateTime                @default(now())
  expiresAt   DateTime? // Optional: when notification expires and is hidden
  isActive    Boolean                 @default(true)
  createdBy   String? // Admin user who created it
  createdAt   DateTime                @default(now())
  updatedAt   DateTime                @updatedAt

  // Relations
  views GlobalNotificationView[]

  @@index([isActive, startsAt])
  @@index([createdAt])
}

// Many-to-many: Tracks which users have viewed each global notification
// This is the "view" or "seen" tracking - use inverse query pattern
model GlobalNotificationView {
  id                    String   @id @default(uuid())
  userId                String
  globalNotificationId  String
  viewedAt              DateTime @default(now())
  dismissed             Boolean  @default(false) // User explicitly dismissed it

  user                AppUser             @relation(fields: [userId], references: [id], onDelete: Cascade)
  globalNotification  GlobalNotification  @relation(fields: [globalNotificationId], references: [id], onDelete: Cascade)

  // Ensure each user is tracked only once per notification
  @@unique([userId, globalNotificationId])
  @@index([globalNotificationId, viewedAt])
  @@index([userId, viewedAt])
}
