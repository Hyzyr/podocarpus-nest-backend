generator client {
  provider   = "prisma-client-js"
  engineType = "library"
}

datasource db {
  provider = "postgresql"
}

enum NotificationType {
  system
  event
  contract
  property
  appointment
  message
  user
}

enum NotificationStatus {
  unread
  read
}

enum UserRole {
  investor
  broker
  admin
  superadmin
}

enum UserActionsStatus {
  seen // seen and no action
  requested // booking created, waiting for approval
  confirmed // scheduled and approved
  completed // appointment done, user visited
  noShow // user did not attend
  canceled // appointment canceled
}

enum ContractStatus {
  draft // contract created but not yet signed
  pending // awaiting approval or payment
  active // signed and currently valid
  suspended // temporarily paused
  expired // reached end date
  terminated // ended early by one or both parties
  completed // fully executed and closed successfully
  canceled // canceled before activation
}

enum ChangeSetStatus {
  draft
  submitted
  approved
  rejected
  applied
  cancelled
}

enum SignatureRole {
  investor
  broker
  admin
}

enum SignatureStatus {
  pending
  signed
  declined
  revoked
}

enum EventStatus {
  DRAFT
  UPCOMING
  OPEN
  // WAITLIST
  ENDED
  CANCELLED
}

model AppUser {
  id           String   @id @default(uuid())
  email        String   @unique
  passwordHash String
  role         UserRole
  // `isEnabled` controls whether the user is allowed to access the system.
  // Set to false to block/disable the user without deleting their data.
  isEnabled    Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // onboarding
  firstName       String?
  lastName        String?
  phone           String?
  nationality     String?
  recidence       String?
  profilePhotoUrl String?

  resetToken          String?
  resetTokenExpiry    DateTime?
  emailVerified       Boolean   @default(false)
  onboardingCompleted Boolean   @default(false)

  investorProfile InvestorProfile?
  brokerProfile   BrokerProfile?
  adminProfile    AdminProfile?
  appointments    Appointment[]

  propertyStatuses        UserPropertyStatus[]
  eventStatuses           UserEventStatus[]
  activityLogs            ActivityLog[]
  notifications           Notification[]
  globalNotificationViews GlobalNotificationView[]
  userKycProfile          UserKycProfile?
}

model InvestorProfile {
  userId String  @id
  user   AppUser @relation(fields: [userId], references: [id], onDelete: Cascade)

  properties  Property[]
  contracts   Contract[]
  preferences InvestorPreferences?
}

model InvestorPreferences {
  investorProfileId String          @id
  investorProfile   InvestorProfile @relation(fields: [investorProfileId], references: [userId], onDelete: Cascade)

  investingInDubai       Boolean
  openToJointInvestments Boolean
  wantsAdvisorCall       Boolean
  interestedInEvents     Boolean
  createdAt              DateTime @default(now())
  updatedAt              DateTime @updatedAt
}

model BrokerProfile {
  userId    String     @id
  user      AppUser    @relation(fields: [userId], references: [id], onDelete: Cascade)
  contracts Contract[]
}

model AdminProfile {
  userId     String  @id
  department String?
  user       AppUser @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// -------------------- USER KYC PROFILE - Identity & Verification --------------------
// Stores user identity documents for verification and contract autofill
model UserKycProfile {
  id     String @id @default(uuid())
  userId String @unique
  
  // Identity Documents (used for contract autofill)
  emiratesId Json? @db.Json // { nameEn, nameAr, idNumber, nationality, gender, expiryDate, unifiedNumber, fileNumber, dateOfBirth, placeOfBirth, isCitizenChild }
  passport   Json? @db.Json // { number, passportType, nationality, issuePlace, issueDate, expiryDate, dateOfBirth, placeOfBirth }
  
  // Verification Documents (used for contract autofill)
  documents Json? @db.Json // { emiratesIdCopy, passportCopy, visaCopy, utilityBill, bankStatement, personalPhoto }

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user AppUser @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Property {
  id                String   @id @default(uuid())
  title             String
  description       String?
  area              String?
  buildingName      String?
  contractValue     Float    @default(1000) // for Investors
  developer         String?
  unitNo            String?
  floor             Int?
  condition         String?
  unitTotalSize     Float?
  apartmentSize     Float?
  balconySize       Float?
  status            String?
  latitude          Float?
  longitude         Float?
  city              String?
  country           String?
  images            String[]
  assets            String[]
  // `isEnabled` controls whether the property is visible/available to users.
  // Set to false to hide the property without deleting contract/investment data.
  isEnabled         Boolean  @default(true)
  netRoiMin         Float? // e.g. 9
  netRoiMax         Float? // e.g. 11
  isTaxFreeZone     Boolean? // true/false
  keyBenefits       String[] // ["100% Foreign Ownership", "Tax-Free Zone", "Full Capital Repatriation"]
  freezoneAuthority String? // e.g. "DMCC Freezone"

  // Current vacancy status
  isVacant Boolean @default(true)

  // Admin
  serviceChargePerSqft Float?
  serviceChargeTotal   Float?
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  // ❗ owner is optional, survives if investor removed
  ownerId String?
  owner   InvestorProfile? @relation(fields: [ownerId], references: [userId], onDelete: SetNull)

  governmentLeases  GovernmentLease[]
  availabilitySlots AvailabilitySlot[]
  appointments      Appointment[]
  userStatuses      UserPropertyStatus[]
  contracts         Contract[]
  tenantLeases      TenantLease[]
}

model GovernmentLease {
  id          String   @id @default(uuid())
  propertyId  String
  startDate   DateTime
  endDate     DateTime
  monthlyRent Float

  property Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)
}

model TenantLease {
  id         String @id @default(uuid())
  propertyId String

  // Tenant details
  tenantName  String?
  tenantEmail String?
  tenantPhone String?

  // Lease terms
  leaseStart    DateTime
  leaseEnd      DateTime?
  monthlyRent   Float
  paymentMethod String?
  depositAmount Float?

  // Status
  isActive          Boolean @default(true)
  terminatedEarly   Boolean @default(false)
  terminationReason String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  property   Property               @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  statistics InvestmentStatistics[]

  @@index([propertyId])
  @@index([leaseStart, leaseEnd])
}

model AvailabilitySlot {
  id         String   @id @default(uuid())
  propertyId String
  startsAt   DateTime
  endsAt     DateTime
  capacity   Int      @default(1)

  property     Property      @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  appointments Appointment[]
}

model Appointment {
  id          String            @id @default(uuid())
  propertyId  String
  bookedById  String
  slotId      String?
  status      UserActionsStatus @default(requested)
  scheduledAt DateTime
  notes       String?

  property Property          @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  bookedBy AppUser           @relation(fields: [bookedById], references: [id], onDelete: Cascade)
  slot     AvailabilitySlot? @relation(fields: [slotId], references: [id], onDelete: SetNull)
}

model Contract {
  id           String   @id @default(uuid())
  propertyId   String
  investorId   String
  brokerId     String?
  contractCode String
  contractLink String?
  filesUrl     String[]

  // Single JSON field for all contract form data
  formData Json? @db.Json // { contractDetails, buyerDetails, emiratesId, passportId, documents }

  // Core dates & finance
  signedDate            DateTime?
  contractStart         DateTime?
  contractEnd           DateTime?
  contractValue         Float?
  depositPaid           Float?
  investorPaymentMethod String?
  paymentSchedule       String?
  vacancyRiskLevel      String?

  status ContractStatus @default(pending)
  notes  String?

  // Versioning
  version          Int     @default(1) // optimistic concurrency
  currentVersionId String?

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  // Relations (existing)
  investor   InvestorProfile        @relation(fields: [investorId], references: [userId], onDelete: Cascade)
  broker     BrokerProfile?         @relation(fields: [brokerId], references: [userId], onDelete: SetNull)
  property   Property               @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  statistics InvestmentStatistics[]

  // New relations
  versions   ContractVersion[]
  changeSets ContractChangeSet[]
  signatures ContractSignature[]
  timeline   ContractEvent[]

  @@index([status, updatedAt])
  @@index([propertyId])
  @@index([investorId])
}

// -------------------- NEW MODELS --------------------
model ContractVersion {
  id            String   @id @default(uuid())
  contractId    String
  versionNumber Int
  snapshot      Json     @db.Json // full immutable snapshot
  createdById   String?
  createdAt     DateTime @default(now())

  contract Contract @relation(fields: [contractId], references: [id], onDelete: Cascade)

  @@unique([contractId, versionNumber])
  @@index([contractId, createdAt])
}

model ContractChangeSet {
  id          String          @id @default(uuid())
  contractId  String
  baseVersion Int // for optimistic lock
  patch       Json            @db.Json // JSON Merge Patch (RFC 7386)
  reason      String?
  status      ChangeSetStatus @default(draft)

  requestedById String?
  reviewedById  String?
  approvedById  String?

  submittedAt DateTime?
  reviewedAt  DateTime?
  approvedAt  DateTime?
  appliedAt   DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  contract Contract @relation(fields: [contractId], references: [id], onDelete: Cascade)

  @@index([contractId, status])
  @@index([contractId, baseVersion])
}

model ContractSignature {
  id         String          @id @default(uuid())
  contractId String
  role       SignatureRole
  signerId   String?
  status     SignatureStatus @default(pending)
  signedAt   DateTime?
  evidence   Json?           @db.Json // IP, device, provider payload…

  contract Contract @relation(fields: [contractId], references: [id], onDelete: Cascade)

  @@index([contractId, role, status])
}

model ContractEvent {
  id         String   @id @default(uuid())
  contractId String
  type       String // "changeset_submitted" | "applied" | "signature_signed" | ...
  data       Json?    @db.Json
  actorId    String?
  createdAt  DateTime @default(now())

  contract Contract @relation(fields: [contractId], references: [id], onDelete: Cascade)

  @@index([contractId, createdAt])
  @@index([type])
}

model InvestmentStatistics {
  id            String  @id @default(uuid())
  contractId    String
  tenantLeaseId String? // Which tenant was active this month
  month         Int // 1-12
  year          Int

  // Income
  rentReceived Float @default(0)

  // Expenses
  serviceCharge   Float @default(0)
  maintenanceCost Float @default(0)
  otherExpenses   Float @default(0)

  // Calculated fields
  totalExpenses Float @default(0)
  netProfit     Float @default(0)
  roiPercentage Float @default(0)

  // Cumulative tracking for charts
  cumulativeProfit Float @default(0) // Running total profit
  cumulativeRoi    Float @default(0) // Running ROI %

  // Occupancy tracking
  daysOccupied Int     @default(0)
  daysVacant   Int     @default(0)
  wasVacant    Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  contract    Contract     @relation(fields: [contractId], references: [id], onDelete: Cascade)
  tenantLease TenantLease? @relation(fields: [tenantLeaseId], references: [id], onDelete: SetNull)

  @@unique([contractId, month, year])
  @@index([contractId])
  @@index([year, month])
}

model Event {
  id          String    @id @default(uuid())
  title       String
  description String?
  startsAt    DateTime
  endsAt      DateTime?
  location    String?

  // New fields
  totalMembers Int? // optional: can be stored or derived
  budget       Decimal?    @db.Decimal(10, 2)
  status       EventStatus @default(OPEN)
  image        String

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userStatuses UserEventStatus[]
}

model UserPropertyStatus {
  id         String   @id @default(uuid())
  userId     String
  propertyId String
  seen       Boolean  @default(false)
  viewedAt   DateTime @default(now())

  user     AppUser  @relation(fields: [userId], references: [id], onDelete: Cascade)
  property Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)

  @@unique([userId, propertyId])
  @@index([propertyId])
}

model UserEventStatus {
  id       String   @id @default(uuid())
  userId   String
  eventId  String
  viewedAt DateTime @default(now())

  status UserActionsStatus @default(seen)
  user   AppUser           @relation(fields: [userId], references: [id], onDelete: Cascade)
  event  Event             @relation(fields: [eventId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, eventId])
  @@index([eventId])
}

model ActivityLog {
  id        String   @id @default(uuid())
  userId    String
  type      String // e.g. "property_viewed", "event_seen", "login"
  entityId  String? // optional: link to property/event/etc
  metadata  Json? // store extra details if needed
  createdAt DateTime @default(now())

  user AppUser @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, type])
  @@index([entityId])
}

model Notification {
  id          String             @id @default(uuid())
  userId      String?
  type        NotificationType   @default(system)
  title       String
  message     String
  targetRoles UserRole[]
  link        String? // optional deep link (e.g. /contracts/123)
  status      NotificationStatus @default(unread)
  createdAt   DateTime           @default(now())
  isGlobal    Boolean?           @default(false)
  readAt      DateTime?
  json        Json?

  user AppUser? @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// Global Notifications: One notification, many users (reverse inbox pattern)
// Used for system-wide announcements, maintenance alerts, feature releases, etc.
model GlobalNotification {
  id          String           @id @default(uuid())
  title       String
  message     String
  type        NotificationType @default(system)
  targetRoles UserRole[] // Which roles should see this
  link        String? // Optional deep link
  priority    String           @default("normal") // "low", "normal", "high", "critical"
  icon        String? // emoji or icon identifier
  json        Json? // Additional metadata
  startsAt    DateTime         @default(now())
  expiresAt   DateTime? // Optional: when notification expires and is hidden
  isActive    Boolean          @default(true)
  createdBy   String? // Admin user who created it
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  // Relations
  views GlobalNotificationView[]

  @@index([isActive, startsAt])
  @@index([createdAt])
}

// Many-to-many: Tracks which users have viewed each global notification
// This is the "view" or "seen" tracking - use inverse query pattern
model GlobalNotificationView {
  id                   String   @id @default(uuid())
  userId               String
  globalNotificationId String
  viewedAt             DateTime @default(now())
  dismissed            Boolean  @default(false) // User explicitly dismissed it

  user               AppUser            @relation(fields: [userId], references: [id], onDelete: Cascade)
  globalNotification GlobalNotification @relation(fields: [globalNotificationId], references: [id], onDelete: Cascade)

  // Ensure each user is tracked only once per notification
  @@unique([userId, globalNotificationId])
  @@index([globalNotificationId, viewedAt])
  @@index([userId, viewedAt])
}
